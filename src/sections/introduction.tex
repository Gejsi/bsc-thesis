\chapter{Introduction}
\label{chap:introduction}
Modern software development requires complex tooling to handle
the intricate landscape encompassing the actual code and business logic.
Besides the program implementation, there are many components to consider
when thinking about all the moving parts needed to make software work
in today's dynamic environments, which are supposed to be scalable by design.

Traditionally, software was written in monolithic architectures where
the program's components are tightly coupled and tend to create
large codebases, as they provide heterogeneous functionalities under the same interface.
This paradigm, despite being the oldest, still has some benefits that
draw developers' attention especially in the early stages of the development lifecycle.
Indeed, these architectures are easier to write because they do not need advanced orchestration mechanisms,
they simplify testing and debugging, and they provide the maximum amount of control over the infrastructure:
this means that developers have the authority to configure, manage,
and optimize each component of the application according to their preferences and requirements.
To illustrate, consider an e-commerce application where all features,
from user authentication to order processing, are bundled together within a monolithic structure:
in this context, the developers decide how all the software units interact
and how resources are allocated to ensure optimal performance.
Yet, the drawbacks of this paradigm were understood even in the past:
a case in point is the \textit{Unix} community, which moved away from it,
preferring a modular approach instead \cite{unix}. Monoliths are hard to maintain, deploy,
adapt to changing requirements and technologies, and they
become rigid quickly as reshaping its components may involuntarily cause a chain of problems.

The modular approach, where features are developed in
independent software units, gained popularity especially in the cloud services realm.
The de facto standard of cloud architectures is represented by \textit{microservices},
which arrange programs into collections of loosely coupled, fine-grained services
that communicate through protocols such as HTTP.
A microservice is a self-contained service, organized around a specific set
of needed business capabilities, that lets developers easily implement a layered architecture
using different technologies (e.g., programming languages, databases, etc.).
This distributed architectural pattern overcomes the shortcomings of monoliths,
as its modular nature makes it scalable, easily deployable, and allows different teams
to work together without the risk of taking down the entire structure when a minor issue arrives.

Still, microservices are not the most efficient way of implementing cloud computing architectures,
since they are long-running processes whose deployment needs to be carefully planned and managed
by configuring the underlying infrastructure. To reduce these operational costs,
serverless architectures were recently created.

The serverless paradigm promises to let its users focus simply on the business logic,
by shifting to the cloud platform provider the infrastructure management,
resources allocation and provisioning, thus enabling software units to scale automatically on demand.
In this model, users write the code inside single-purpose units (i.e., programming languages' functions),
even smaller than microservices in responsibility,
and they set which event will trigger their invocation.
This event-driven model of dispatching actions is very efficient, in fact,
when a function is triggered, the cloud vendor executes it in an isolated, secure, and short-lived environment.
Consequently, users are only billed for the precise resources consumed during this execution period.

Serverless is not free of disadvantages and, while traditional solutions
had generations of practitioners and researchers improving the development experience
by providing guidelines, best practices, and tools suited for each phase
of the development lifecycle (design, programming, debugging, maintenance, etc.),
the serverless model is still in its infancy and lacks a similar depth of accumulated wisdom and refinement.

\section{Objectives}

In this thesis, we present \f{}, a framework which aims to enhance serverless programming
by simplifying the development of cloud functions through its meta-programming functionalities.
Users mark the serverless functions with annotations that signal the \f{} compiler
which code transformations are going to be needed and which metadata will be used
for their deployment, therefore streamlining different parts of the development lifecycle simultaneously.
\f{} transpiles \textit{JavaScript} codebases whose functions are executed
through \textit{AWS Lambda}'s \textit{Node.js} runtime.
This is accompanied by the seamless management of projects
through its user-friendly CLI, ensuring an efficient and graceful path
into the adoption of the serverless model.
