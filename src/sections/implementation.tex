\chapter{Implementation}
\label{chap:implementation}

This chapter presents an in-depth description of how \f{} works
and demonstrates how much it can simplify developers' experience
by showing real-world examples with extensive usage of its features.
Furthermore, since we are creating an open-source project, the structure of
the repository will also be analyzed.


\section{Overview}

\f{} is a transpiler which enhances serverless programming by introducing the concept of annotations.
Annotations are an abstraction layer that the developers can unobtrusively use
to apply code transformations and metadata generation to a given application,
which will be deployed to a serverless platform.

To achieve this goal, we used the \textit{TypeScript}\cite{ts} compiler API which lets us
manipulate sources with ease, and \textit{SLS}\cite{sls} which
uses the generated metadata to deploy to \textit{AWS Lambda}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{diagrams/pipeline}
  \caption{Transpiler pipeline.}
  \label{fig:pipeline}
\end{figure}

The transpilation pipeline, depicted in Figure \ref{fig:pipeline},
starts with the parsing of the input source code, which produces AST nodes with their related
annotations. Then, each annotation induces the application of its related
transformation step, whose output is fed into the next transformer, if any.
During the transformation steps, \f{} reports possible errors by gracefully
stopping the compilation process and indicating the offending instructions. Once
the transformations have taken place without any errors, the output code is saved
and the related metadata is also appended to a
\verb|serverless.yml| file which specifies function deployment
properties (e.g., the address to invoke a given function).

It is important to notice that \f{} doesn't lock developers in managing their
functions only through its tools, instead, its primary objective is to facilitate
the incremental adoption of the serverless paradigm.

\subsection{Brief example: Monolith to Serverless conversion}

Lorem ipsum dolor sit amet, qui minim labore adipisicing minim sint cillum sint consectetur cupidatat.

\section{Detailed review}

This section explains each step of the pipeline, defines annotations precisely and shows how to create new ones.

\subsection{Parsing}

\f{} requires a configuration file, that must be named \verb|fenrir.config.json|, to understand where to operate:

\begin{lstlisting}[language=json]
{
  "files": ["input/source.ts"],
  "serverlessConfigPath": "input/serverless.yml",
  "outputDirectory": "output",
  "annotations": {
    "CustomAnnotation": "annotations/custom-annotation.ts"
  }
}
\end{lstlisting}

The \verb|files| field accepts an array of filenames or a directory,
and it is used to represent which files will be parsed by the transpiler.

The \verb|serverlessConfigPath| field points at the input \textit{SLS} configuration
that must contain some mandatory input metadata, such as the region which the functions will be deployed on.

The \verb|outputDirectory| field indicates where the emitted files will be placed.

The \verb|annotations| field locates custom annotations as it takes an object
where the keys represent the new names and the values refer to their associated implementations.

\paragraph{\textbf{Fenrir's CLI}}
After creating the configuration, \f{} can be started through our CLI tool
by optionally passing as a flag the directory in which it is contained.
\begin{lstlisting}[language=bash, style=bashstyle]
# defaults to the current directory (.) for its file lookup...
> fenrir
# ...or uses a custom path
> fenrir -g input-directory
\end{lstlisting}
Furthermore, the CLI offers the \verb|init| sub-command to ease the setup needed for the entire pipeline
by generating the necessary boilerplate and configuration files.

% TODO: ricorda di parlare di quanto sia ottimo il compiler api di ts in Background.
% perchÃ© ha informazioni su tutto il progetto e non solo sui file.
\subsubsection{AST Traversal}

Through the \textit{TypeScript} compiler API, each sources' AST is traversed
by a visitor function which collects some data (e.g., dependencies imports) and examines
certain types of node in order to process annotations, namely \textit{exported function declarations}.
Lookups are restricted only to this syntactic category for two reasons:
\begin{itemize}
  \item \verb|export| ensures the functions are public and ready to be deployed.
  \item \verb|function declarations| minimize the code needed to control the AST.
    Considering that \textit{JavaScript} provides three distinct ways of declaring a function,
    accommodating all of these variations would inevitably result in a threefold expansion of the manipulation code.
    Moreover, function declarations are the idiomatic technique to write top-level functions.
\end{itemize}

\begin{lstlisting}[language=javascript, caption={Examples of examined or skipped nodes.}]
// Skipped
const a = 2;
// Skipped
for (const b of [1, 2, 3]) {}
// Accepted
export function foo() {}
// Skipped
export const fiz = () => {}
// Skipped
export const bar = function() {}
\end{lstlisting}

The accepted functions are further examined as their annotations are processed, and
their bodies are visited to handle AST transformations.

\subsection{Annotations}

Annotations are syntactical units, or keywords, enclosed within JSDoc comments,
each associated with its respective transformer.
They can be expressed using a BNF-like syntax:
\begin{equation*}
\begin{aligned}
    \langle \text{Annotation} \rangle & ::= "\$" \langle \text{Name} \rangle [ "(" \langle \text{Object} \rangle ")" ] \\
    \langle \text{Name} \rangle & ::= [\text{a-zA-Z\_}][\text{a-zA-Z0-9\_}]* \\
    \langle \text{Object} \rangle & ::= \langle \text{TypeScriptObject} \rangle \\
    \langle \text{TypeScriptObject} \rangle & ::= \dots \\
\end{aligned}
\end{equation*}
This representation does not intend to provide a formal and precise depiction of the syntax of annotations.
Nevertheless, it serves to offer a general impression of how they can be written within the code.
\begin{lstlisting}[language=javascript, caption={Generic examples of annotation.}]
/** $\dollar$Foo */

/** $\dollar$Bar(param: "first") */

/** $\dollar$Fiz(first: true, second: [1, 2, 3], third: (a, b) => a + b) */
\end{lstlisting}


\subsection{Emit}

Magari parlare della gestione degli errori. E poi dell'emit.
